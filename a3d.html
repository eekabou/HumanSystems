<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js OrbitControls 예제</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            color: #fff;
        }

        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-color: #111;
        }

        .content {
            position: relative;
            z-index: 1;
            padding: 40px;
            text-align: center;
        }

        .content h1 {
            font-size: 3em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .content p {
            font-size: 1.2em;
            max-width: 600px;
            margin: 20px auto;
            line-height: 1.6;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <canvas id="bg-canvas"></canvas>

    <div class="content">
        <h1>마우스로 드래그하여 둘러보세요</h1>
        <p>이제 마우스 왼쪽 버튼을 누르고 드래그하여 모델을 회전시킬 수 있습니다. 마우스 휠을 사용하여 줌인/줌아웃도 가능합니다.</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        // 1. OrbitControls를 import 합니다.
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50; // 모델이 잘 보이도록 카메라를 뒤로 뺍니다.

        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector('#bg-canvas'),
            antialias: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // 2. OrbitControls를 생성합니다.
        // 카메라와 렌더러의 DOM 요소를 인자로 전달합니다.
        const controls = new OrbitControls(camera, renderer.domElement);
        
        // 3. OrbitControls 옵션 설정 (선택 사항)
        controls.enableDamping = true; // 부드러운 움직임 효과
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false; // 패닝(이동) 제한
        controls.minDistance = 5; // 최소 줌 거리
        controls.maxDistance = 50; // 최대 줌 거리
        controls.maxPolarAngle = Math.PI / 2; // 수직 회전 각도 제한 (아래에서 위로 못보게)

        const loader = new GLTFLoader();
        let model;

        loader.load(
            'Starblast_Venator.glb',
            (gltf) => {
                model = gltf.scene;
                model.scale.set(5, 5, 5); // 모델 크기를 다시 5배로 설정
                model.position.set(0, 0, 0); // 모델 위치를 중앙으로
                scene.add(model);
            },
            undefined,
            (error) => {
                console.error('모델 로딩 중 오류 발생:', error);
            }
        );

        // (삭제) 마우스 움직임에 따라 모델을 회전시키는 코드는 이제 필요 없습니다.
        // OrbitControls가 이 역할을 대신합니다.
        // document.addEventListener('mousemove', ...); 부분 삭제

        function animate() {
            requestAnimationFrame(animate);

            // 4. 애니메이션 루프에서 controls를 업데이트합니다.
            // enableDamping을 true로 설정했을 경우 필수입니다.
            controls.update();

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>